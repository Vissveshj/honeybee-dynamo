<!doctype html>
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />

    <title>honeybeex.honeybee._hbanalysissurface API documentation</title>
    <meta name="description" content="" />

  <link href='http://fonts.googleapis.com/css?family=Source+Sans+Pro:400,300' rel='stylesheet' type='text/css'>

  <!-- highlight.js for highlighting source code. -->
  <link rel="stylesheet" href="http://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.2.0/styles/default.min.css">
  <script src="http://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.2.0/highlight.min.js"></script>

  
  <style type="text/css">
  
* {
  box-sizing: border-box;
}
/*! normalize.css v1.1.1 | MIT License | git.io/normalize */

/* ==========================================================================
   HTML5 display definitions
   ========================================================================== */

/**
 * Correct `block` display not defined in IE 6/7/8/9 and Firefox 3.
 */

article,
aside,
details,
figcaption,
figure,
footer,
header,
hgroup,
main,
nav,
section,
summary {
    display: block;
}

/**
 * Correct `inline-block` display not defined in IE 6/7/8/9 and Firefox 3.
 */

audio,
canvas,
video {
    display: inline-block;
    *display: inline;
    *zoom: 1;
}

/**
 * Prevent modern browsers from displaying `audio` without controls.
 * Remove excess height in iOS 5 devices.
 */

audio:not([controls]) {
    display: none;
    height: 0;
}

/**
 * Address styling not present in IE 7/8/9, Firefox 3, and Safari 4.
 * Known issue: no IE 6 support.
 */

[hidden] {
    display: none;
}

/* ==========================================================================
   Base
   ========================================================================== */

/**
 * 1. Prevent system color scheme's background color being used in Firefox, IE,
 *    and Opera.
 * 2. Prevent system color scheme's text color being used in Firefox, IE, and
 *    Opera.
 * 3. Correct text resizing oddly in IE 6/7 when body `font-size` is set using
 *    `em` units.
 * 4. Prevent iOS text size adjust after orientation change, without disabling
 *    user zoom.
 */

html {
    background: #fff; /* 1 */
    color: #000; /* 2 */
    font-size: 100%; /* 3 */
    -webkit-text-size-adjust: 100%; /* 4 */
    -ms-text-size-adjust: 100%; /* 4 */
}

/**
 * Address `font-family` inconsistency between `textarea` and other form
 * elements.
 */

html,
button,
input,
select,
textarea {
    font-family: sans-serif;
}

/**
 * Address margins handled incorrectly in IE 6/7.
 */

body {
    margin: 0;
}

/* ==========================================================================
   Links
   ========================================================================== */

/**
 * Address `outline` inconsistency between Chrome and other browsers.
 */

a:focus {
    outline: thin dotted;
}

/**
 * Improve readability when focused and also mouse hovered in all browsers.
 */

a:active,
a:hover {
    outline: 0;
}

/* ==========================================================================
   Typography
   ========================================================================== */

/**
 * Address font sizes and margins set differently in IE 6/7.
 * Address font sizes within `section` and `article` in Firefox 4+, Safari 5,
 * and Chrome.
 */

h1 {
    font-size: 2em;
    margin: 0.67em 0;
}

h2 {
    font-size: 1.5em;
    margin: 0.83em 0;
}

h3 {
    font-size: 1.17em;
    margin: 1em 0;
}

h4 {
    font-size: 1em;
    margin: 1.33em 0;
}

h5 {
    font-size: 0.83em;
    margin: 1.67em 0;
}

h6 {
    font-size: 0.67em;
    margin: 2.33em 0;
}

/**
 * Address styling not present in IE 7/8/9, Safari 5, and Chrome.
 */

abbr[title] {
    border-bottom: 1px dotted;
}

/**
 * Address style set to `bolder` in Firefox 3+, Safari 4/5, and Chrome.
 */

b,
strong {
    font-weight: bold;
}

blockquote {
    margin: 1em 40px;
}

/**
 * Address styling not present in Safari 5 and Chrome.
 */

dfn {
    font-style: italic;
}

/**
 * Address differences between Firefox and other browsers.
 * Known issue: no IE 6/7 normalization.
 */

hr {
    -moz-box-sizing: content-box;
    box-sizing: content-box;
    height: 0;
}

/**
 * Address styling not present in IE 6/7/8/9.
 */

mark {
    background: #ff0;
    color: #000;
}

/**
 * Address margins set differently in IE 6/7.
 */

p,
pre {
    margin: 1em 0;
}

/**
 * Correct font family set oddly in IE 6, Safari 4/5, and Chrome.
 */

code,
kbd,
pre,
samp {
    font-family: monospace, serif;
    _font-family: 'courier new', monospace;
    font-size: 0.9em;
}

/**
 * Improve readability of pre-formatted text in all browsers.
 */

pre {
    white-space: pre;
    white-space: pre-wrap;
    word-wrap: break-word;
}

/**
 * Address CSS quotes not supported in IE 6/7.
 */

q {
    quotes: none;
}

/**
 * Address `quotes` property not supported in Safari 4.
 */

q:before,
q:after {
    content: '';
    content: none;
}

/**
 * Address inconsistent and variable font size in all browsers.
 */

small {
    font-size: 80%;
}

/**
 * Prevent `sub` and `sup` affecting `line-height` in all browsers.
 */

sub,
sup {
    font-size: 75%;
    line-height: 0;
    position: relative;
    vertical-align: baseline;
}

sup {
    top: -0.5em;
}

sub {
    bottom: -0.25em;
}

/* ==========================================================================
   Lists
   ========================================================================== */

/**
 * Address margins set differently in IE 6/7.
 */

dl,
menu,
ol,
ul {
    margin: 1em 0;
}

dd {
    margin: 0 0 0 40px;
}

/**
 * Address paddings set differently in IE 6/7.
 */

menu,
ol,
ul {
    padding: 0 0 0 40px;
}

/**
 * Correct list images handled incorrectly in IE 7.
 */

nav ul,
nav ol {
    list-style: none;
    list-style-image: none;
}

/* ==========================================================================
   Embedded content
   ========================================================================== */

/**
 * 1. Remove border when inside `a` element in IE 6/7/8/9 and Firefox 3.
 * 2. Improve image quality when scaled in IE 7.
 */

img {
    border: 0; /* 1 */
    -ms-interpolation-mode: bicubic; /* 2 */
}

/**
 * Correct overflow displayed oddly in IE 9.
 */

svg:not(:root) {
    overflow: hidden;
}

/* ==========================================================================
   Figures
   ========================================================================== */

/**
 * Address margin not present in IE 6/7/8/9, Safari 5, and Opera 11.
 */

figure {
    margin: 0;
}

/* ==========================================================================
   Forms
   ========================================================================== */

/**
 * Correct margin displayed oddly in IE 6/7.
 */

form {
    margin: 0;
}

/**
 * Define consistent border, margin, and padding.
 */

fieldset {
    border: 1px solid #c0c0c0;
    margin: 0 2px;
    padding: 0.35em 0.625em 0.75em;
}

/**
 * 1. Correct color not being inherited in IE 6/7/8/9.
 * 2. Correct text not wrapping in Firefox 3.
 * 3. Correct alignment displayed oddly in IE 6/7.
 */

legend {
    border: 0; /* 1 */
    padding: 0;
    white-space: normal; /* 2 */
    *margin-left: -7px; /* 3 */
}

/**
 * 1. Correct font size not being inherited in all browsers.
 * 2. Address margins set differently in IE 6/7, Firefox 3+, Safari 5,
 *    and Chrome.
 * 3. Improve appearance and consistency in all browsers.
 */

button,
input,
select,
textarea {
    font-size: 100%; /* 1 */
    margin: 0; /* 2 */
    vertical-align: baseline; /* 3 */
    *vertical-align: middle; /* 3 */
}

/**
 * Address Firefox 3+ setting `line-height` on `input` using `!important` in
 * the UA stylesheet.
 */

button,
input {
    line-height: normal;
}

/**
 * Address inconsistent `text-transform` inheritance for `button` and `select`.
 * All other form control elements do not inherit `text-transform` values.
 * Correct `button` style inheritance in Chrome, Safari 5+, and IE 6+.
 * Correct `select` style inheritance in Firefox 4+ and Opera.
 */

button,
select {
    text-transform: none;
}

/**
 * 1. Avoid the WebKit bug in Android 4.0.* where (2) destroys native `audio`
 *    and `video` controls.
 * 2. Correct inability to style clickable `input` types in iOS.
 * 3. Improve usability and consistency of cursor style between image-type
 *    `input` and others.
 * 4. Remove inner spacing in IE 7 without affecting normal text inputs.
 *    Known issue: inner spacing remains in IE 6.
 */

button,
html input[type="button"], /* 1 */
input[type="reset"],
input[type="submit"] {
    -webkit-appearance: button; /* 2 */
    cursor: pointer; /* 3 */
    *overflow: visible;  /* 4 */
}

/**
 * Re-set default cursor for disabled elements.
 */

button[disabled],
html input[disabled] {
    cursor: default;
}

/**
 * 1. Address box sizing set to content-box in IE 8/9.
 * 2. Remove excess padding in IE 8/9.
 * 3. Remove excess padding in IE 7.
 *    Known issue: excess padding remains in IE 6.
 */

input[type="checkbox"],
input[type="radio"] {
    box-sizing: border-box; /* 1 */
    padding: 0; /* 2 */
    *height: 13px; /* 3 */
    *width: 13px; /* 3 */
}

/**
 * 1. Address `appearance` set to `searchfield` in Safari 5 and Chrome.
 * 2. Address `box-sizing` set to `border-box` in Safari 5 and Chrome
 *    (include `-moz` to future-proof).
 */

input[type="search"] {
    -webkit-appearance: textfield; /* 1 */
    -moz-box-sizing: content-box;
    -webkit-box-sizing: content-box; /* 2 */
    box-sizing: content-box;
}

/**
 * Remove inner padding and search cancel button in Safari 5 and Chrome
 * on OS X.
 */

input[type="search"]::-webkit-search-cancel-button,
input[type="search"]::-webkit-search-decoration {
    -webkit-appearance: none;
}

/**
 * Remove inner padding and border in Firefox 3+.
 */

button::-moz-focus-inner,
input::-moz-focus-inner {
    border: 0;
    padding: 0;
}

/**
 * 1. Remove default vertical scrollbar in IE 6/7/8/9.
 * 2. Improve readability and alignment in all browsers.
 */

textarea {
    overflow: auto; /* 1 */
    vertical-align: top; /* 2 */
}

/* ==========================================================================
   Tables
   ========================================================================== */

/**
 * Remove most spacing between table cells.
 */

table {
    border-collapse: collapse;
    border-spacing: 0;
}

  </style>

  <style type="text/css">
  
  html, body {
    margin: 0;
    padding: 0;
    min-height: 100%;
  }
  body {
    background: #fff;
    font-family: "Source Sans Pro", "Helvetica Neueue", Helvetica, sans;
    font-weight: 300;
    font-size: 16px;
    line-height: 1.6em;
  }
  #content {
    width: 70%;
    margin-left: 25%;
    max-width: 90%;
    float: left;
    padding: 30px 60px;
    border-left: 1px solid #ddd;
  }
  #sidebar {
    position: fixed;
    height: 100%;
    width: 25%;
    float: left;
    padding: 30px;
    overflow-x: hidden;
    overflow-y: auto;
  }
  #nav {
    font-size: 130%;
    margin: 0 0 15px 0;
  }

  #top {
    display: block;
    position: fixed;
    bottom: 5px;
    left: 5px;
    font-size: .85em;
    text-transform: uppercase;
  }

  #footer {
    font-size: .75em;
    padding: 5px 30px;
    border-top: 1px solid #ddd;
    text-align: right;
  }
    #footer p {
      margin: 0 0 0 30px;
      display: inline-block;
    }

  h1, h2, h3, h4, h5 {
    font-weight: 300;
  }
  h1 {
    font-size: 2.5em;
    line-height: 1.1em;
    margin: 0 0 .50em 0;
  }

  h2 {
    font-size: 1.75em;
    margin: 1em 0 .50em 0;
  }

  h3 {
    margin: 25px 0 10px 0;
  }

  h4 {
    margin: 0;
    font-size: 105%;
  }

  a {
    color: #058;
    text-decoration: none;
    transition: color .3s ease-in-out;
  }

  a:hover {
    color: #e08524;
    transition: color .3s ease-in-out;
  }

  pre, code, .mono, .name {
    font-family: "Ubuntu Mono", "Cousine", "DejaVu Sans Mono", monospace;
  }

  .title .name {
    font-weight: bold;
  }
  .section-title {
    margin-top: 2em;
  }
  .ident {
    color: #900;
  }

  pre {
    background: #fefefe;
    border: 1px solid #ddd;
    box-shadow: 2px 2px 0 #f3f3f3;
    margin: 0 30px;
    padding: 15px 30px;
  }

  .codehilite {
    margin: 0 30px 10px 30px;
  }

    .codehilite pre {
      margin: 0;
    }
    .codehilite .err { background: #ff3300; color: #fff !important; }

  table#module-list {
    font-size: 110%;
  }

    table#module-list tr td:first-child {
      padding-right: 10px;
      white-space: nowrap;
    }

    table#module-list td {
      vertical-align: top;
      padding-bottom: 8px;
    }

      table#module-list td p {
        margin: 0 0 7px 0;
      }

  .def {
    display: table;
  }

    .def p {
      display: table-cell;
      vertical-align: top;
      text-align: left;
    }

    .def p:first-child {
      white-space: nowrap;
    }

    .def p:last-child {
      width: 100%;
    }


  #index {
    list-style-type: none;
    margin: 0;
    padding: 0;
  }
    ul#index .class_name {
      /* font-size: 110%; */
      font-weight: bold;
    }
    #index ul {
      margin: 0;
    }

  .item {
    margin: 0 0 15px 0;
  }

    .item .class {
      margin: 0 0 25px 30px;
    }

      .item .class ul.class_list {
        margin: 0 0 20px 0;
      }

    .item .name {
      background: #fafafa;
      margin: 0;
      font-weight: bold;
      padding: 5px 10px;
      border-radius: 3px;
      display: inline-block;
      min-width: 40%;
    }
      .item .name:hover {
        background: #f6f6f6;
      }

    .item .empty_desc {
      margin: 0 0 5px 0;
      padding: 0;
    }

    .item .inheritance {
      margin: 3px 0 0 30px;
    }

    .item .inherited {
      color: #666;
    }

    .item .desc {
      padding: 0 8px;
      margin: 0;
    }

      .item .desc p {
        margin: 0 0 10px 0;
      }

    .source_cont {
      margin: 0;
      padding: 0;
    }

    .source_link a {
      background: #ffc300;
      font-weight: 400;
      font-size: .75em;
      text-transform: uppercase;
      color: #fff;
      text-shadow: 1px 1px 0 #f4b700;

      padding: 3px 8px;
      border-radius: 2px;
      transition: background .3s ease-in-out;
    }
      .source_link a:hover {
        background: #FF7200;
        text-shadow: none;
        transition: background .3s ease-in-out;
      }

    .source {
      display: none;
      max-height: 600px;
      overflow-y: auto;
      margin-bottom: 15px;
    }

      .source .codehilite {
        margin: 0;
      }

  .desc h1, .desc h2, .desc h3 {
    font-size: 100% !important;
  }

  .desc {
    white-space: pre-wrap;
  }

  .clear {
    clear: both;
  }

  @media all and (max-width: 950px) {
    #sidebar {
        position: inherit;
        float: none;
        width: auto;
    }
    #content {
      width: 95%;
      margin-left: auto;
      border-left: none;
      padding: 30px;
    }
  }
  @media all and (max-width: 650px) {
    #top {
      display: none;
    }
    #sidebar {
      float: none;
      width: auto;
    }
    #content {
      float: none;
      width: auto;
      padding: 30px;
    }

    #index ul {
      padding: 0;
      margin-bottom: 15px;
    }
    #index ul li {
      display: inline-block;
      margin-right: 30px;
    }
    #footer {
      text-align: left;
    }
    #footer p {
      display: block;
      margin: inherit;
    }
  }

  /*****************************/

  </style>


  <style type="text/css">
  
/* ==========================================================================
   EXAMPLE Media Queries for Responsive Design.
   These examples override the primary ('mobile first') styles.
   Modify as content requires.
   ========================================================================== */

@media only screen and (min-width: 35em) {
    /* Style adjustments for viewports that meet the condition */
}

@media print,
       (-o-min-device-pixel-ratio: 5/4),
       (-webkit-min-device-pixel-ratio: 1.25),
       (min-resolution: 120dpi) {
    /* Style adjustments for high resolution devices */
}

/* ==========================================================================
   Print styles.
   Inlined to avoid required HTTP connection: h5bp.com/r
   ========================================================================== */

@media print {
    * {
        background: transparent !important;
        color: #000 !important; /* Black prints faster: h5bp.com/s */
        box-shadow: none !important;
        text-shadow: none !important;
    }

    a,
    a:visited {
        text-decoration: underline;
    }

    a[href]:after {
        content: " (" attr(href) ")";
    }

    abbr[title]:after {
        content: " (" attr(title) ")";
    }

    /*
     * Don't show links for images, or javascript/internal links
     */

    .ir a:after,
    a[href^="javascript:"]:after,
    a[href^="#"]:after {
        content: "";
    }

    pre,
    blockquote {
        border: 1px solid #999;
        page-break-inside: avoid;
    }

    thead {
        display: table-header-group; /* h5bp.com/t */
    }

    tr,
    img {
        page-break-inside: avoid;
    }

    img {
        max-width: 100% !important;
    }

    @page {
        margin: 0.5cm;
    }

    p,
    h2,
    h3 {
        orphans: 3;
        widows: 3;
    }

    h2,
    h3 {
        page-break-after: avoid;
    }
}

  </style>

  <script type="text/javascript">
  function toggle(id, $link) {
    $node = document.getElementById(id);
    if (!$node)
    return;
    if (!$node.style.display || $node.style.display == 'none') {
    $node.style.display = 'block';
    $link.innerHTML = 'Hide source &nequiv;';
    } else {
    $node.style.display = 'none';
    $link.innerHTML = 'Show source &equiv;';
    }
  }
  </script>
</head>
<body>
<a href="#" id="top">Top</a>

<div id="container">
    
  
  <div id="sidebar">
    <h1>Index</h1>
    <ul id="index">


    <li class="set"><h3><a href="#header-classes">Classes</a></h3>
      <ul>
        <li class="mono">
        <span class="class_name"><a href="#honeybeex.honeybee._hbanalysissurface.AnalsysiSurfacePolyline">AnalsysiSurfacePolyline</a></span>
        
          
  <ul>
    <li class="mono"><a href="#honeybeex.honeybee._hbanalysissurface.AnalsysiSurfacePolyline.distance">distance</a></li>
    <li class="mono"><a href="#honeybeex.honeybee._hbanalysissurface.AnalsysiSurfacePolyline.__init__">__init__</a></li>
  </ul>

        </li>
        <li class="mono">
        <span class="class_name"><a href="#honeybeex.honeybee._hbanalysissurface.HBAnalysisSurface">HBAnalysisSurface</a></span>
        
          
  <ul>
    <li class="mono"><a href="#honeybeex.honeybee._hbanalysissurface.HBAnalysisSurface.__init__">__init__</a></li>
    <li class="mono"><a href="#honeybeex.honeybee._hbanalysissurface.HBAnalysisSurface.ToString">ToString</a></li>
    <li class="mono"><a href="#honeybeex.honeybee._hbanalysissurface.HBAnalysisSurface.addPoint">addPoint</a></li>
    <li class="mono"><a href="#honeybeex.honeybee._hbanalysissurface.HBAnalysisSurface.addPointList">addPointList</a></li>
    <li class="mono"><a href="#honeybeex.honeybee._hbanalysissurface.HBAnalysisSurface.duplicateVertices">duplicateVertices</a></li>
    <li class="mono"><a href="#honeybeex.honeybee._hbanalysissurface.HBAnalysisSurface.isNameSetByUser">isNameSetByUser</a></li>
    <li class="mono"><a href="#honeybeex.honeybee._hbanalysissurface.HBAnalysisSurface.radStringToFile">radStringToFile</a></li>
    <li class="mono"><a href="#honeybeex.honeybee._hbanalysissurface.HBAnalysisSurface.toEPString">toEPString</a></li>
    <li class="mono"><a href="#honeybeex.honeybee._hbanalysissurface.HBAnalysisSurface.toRadString">toRadString</a></li>
  </ul>

        </li>
      </ul>
    </li>

    </ul>
  </div>

    <article id="content">
      
  

  


  <header id="section-intro">
  <h1 class="title"><span class="name">honeybeex.honeybee._hbanalysissurface</span> module</h1>
  
  
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-honeybeex.honeybee._hbanalysissurface', this);">Show source &equiv;</a></p>
  <div id="source-honeybeex.honeybee._hbanalysissurface" class="source">
    <pre><code>from abc import ABCMeta, abstractproperty
from hbobject import HBObject
from radiance.properties import RadianceProperties
from radiance.geometry import polygon
import surfacetype
import geometryoperation as go
from surfacetype import Floor, Wall, Window, Ceiling
import os
import types
import math


class HBAnalysisSurface(HBObject):
    """Base class for Honeybee surface.

    Args:
        name: A unique string for surface name
        sortedPoints: A list of 3 points or more as tuple or list with three items
            (x, y, z). Points should be sorted. This class won't sort the points.
            If surfaces has multiple subsurfaces you can pass lists of point lists
            to this function (e.g. ((0, 0, 0), (10, 0, 0), (0, 10, 0))).
        surfaceType: Optional input for surface type. You can use any of the surface
            types available from surfacetype libraries or use a float number to
            indicate the type. If not indicated it will be assigned based on normal
            angle of the surface which will be calculated from surface points.
                0.0: Wall           0.5: UndergroundWall
                1.0: Roof           1.5: UndergroundCeiling
                2.0: Floor          2.25: UndergroundSlab
                2.5: SlabOnGrade    2.75: ExposedFloor
                3.0: Ceiling        4.0: AirWall
                5.0: Window         6.0: Context
        isNameSetByUser: If you want the name to be changed by honeybee any case
            set isNameSetByUser to True. Default is set to False which let Honeybee
            to rename the surface in cases like creating a newHBZone.
        radProperties: Radiance properties for this surface. If empty default
            RADProperties will be assigned to surface by Honeybee.
        epProperties: EnergyPlus properties for this surface. If empty default
            epProperties will be assigned to surface by Honeybee.
    """

    __metaclass__ = ABCMeta

    def __init__(self, name, sortedPoints=[], surfaceType=None,
                 isNameSetByUser=False, isTypeSetByUser=False,
                 radProperties=None, epProperties=None):
        """Initialize Honeybee Surface."""
        self.name = (name, isNameSetByUser)
        """Surface name."""
        self.points = sortedPoints
        """A list of points as tuples or lists of (x, y, z).
        Points should be sorted. This class won't sort the points.
        (e.g. ((0, 0, 0), (10, 0, 0), (0, 10, 0)))
        """
        self.surfaceType = (surfaceType, isTypeSetByUser)
        """Surface type."""
        self.epProperties = epProperties
        """EnergyPlus properties for this surface. If empty default
            EPProperties will be assigned to surface by Honeybee."""
        self.radProperties = radProperties
        """Radiance properties for this surface. If empty default
            RADProperties will be assigned to surface by Honeybee.
        """

    @property
    def isHBAnalysisSurface(self):
        """Return True for HBSurface."""
        return True

    @abstractproperty
    def isChildSurface(self):
        """Return True if Honeybee surface is Fenestration Surface."""
        pass

    @abstractproperty
    def parent(self):
        """Return parent for HBAnalysisSurface.

        Parent will be a HBZone for a HBSurface, and a HBSurface for a
        HBFenSurface.
        """
        pass

    @property
    def isRelativeSystem(self):
        """Return True if coordinate system is relative."""
        if self.parent is None:
            return False
        else:
            return self.parent.isRelativeSystem

    @property
    def origin(self):
        """Get origin of the coordinate system for this surface.

        For Absolute system the value is always (0, 0, 0).
        """
        return self.parent.origin

    @property
    def name(self):
        """Retuen surface name."""
        return self.__name

    # TODO: name should be checked not to have illegal charecters for ep and radiance
    @name.setter
    def name(self, values):
        """Set name and isSetByUser property.

        Args:
            values: A name or a tuple as (name, isSetByUser)

        Usage:
            HBSrf.name = "surface_001"
            # or
            HBSrf.name = ("mySurfaceName", True)
        """
        try:
            # check if user passed a tuple
            if type(values) is str:
                raise TypeError
            __newName, __isNameSetByUser = values
        except ValueError:
            # user is passing a list or tuple with one ValueError
            __newName = values[0]
            __isNameSetByUser = False  # if not indicated assume it is not set by user.
        except TypeError:
            # user just passed a single value which is the name
            __newName = values
            __isNameSetByUser = False  # if not indicated assume it is not set by user.
        finally:
            # set new name
            self.__name = str(__newName)
            self.__isNameSetByUser = __isNameSetByUser

    def isNameSetByUser(self):
        """Return if name is set by user.

        If name is set by user the surface will never be renamed automatically.
        """
        return self.__isNameSetByUser

    @property
    def surfaceTypes(self):
        """Return Honeybee valid surface types."""
        _surfaceTypes = {0.0: 'Wall', 0.5: 'UndergroundWall', 1.0: 'Roof',
                         1.5: 'UndergroundCeiling', 2.0: 'Floor',
                         2.25: 'UndergroundSlab', 2.5: 'SlabOnGrade',
                         2.75: 'ExposedFloor', 3.0: 'Ceiling', 4.0: 'AirWall',
                         6.0: 'Context'}

        return _surfaceTypes

    @property
    def surfaceType(self):
        """Get and set Surface Type."""
        return self.__surfaceType

    @surfaceType.setter
    def surfaceType(self, values):
        # let's assume values in surfaceType and Boolean
        __surfaceType, __isTypeSetByUser = values

        # Now let's check the input for surface type
        if __surfaceType is not None:
            # it is either a number or already a valid type
            if isinstance(__surfaceType, surfacetype.surfaceTypeBase):
                self.__surfaceType = __surfaceType
            else:
                try:
                    # it should be a key value
                    self.__surfaceType = \
                        surfacetype.SurfaceTypes.getTypeByKey(__surfaceType)()
                except:
                    raise ValueError('%s is not a valid surface type.' % __surfaceType)
        else:
            # try to figure it out based on points
            if self.points == []:
                # unless user add the points we can't find the type
                self.__surfaceType = None
            else:
                self.__surfaceType = self.__surfaceTypeFromPoints()
                __isTypeSetByUser = False

        self.__isTypeSetByUser = __isTypeSetByUser

    def __surfaceTypeFromPoints(self):
        normal = go.calculateNormalFromPoints(self.points[0])
        __angleToZAxis = go.calculateVectorAngleToZAxis(normal)
        return surfacetype.SurfaceTypes.byNormalAngleAndPoints(__angleToZAxis, self.points[0])()

    @property
    def isTypeSetByUser(self):
        """Check if the type for surface is set by user."""
        return self.__isTypeSetByUser

    @property
    def isFloor(self):
        """Check if surface is a Floor."""
        return isinstance(self.surfaceType, Floor)

    @property
    def isWall(self):
        """Check if surface is a Wall."""
        return isinstance(self.surfaceType, Wall)

    @property
    def isCeiling(self):
        """Check if surface is a Ceiling."""
        return isinstance(self.surfaceType, Ceiling)

    @property
    def isWindow(self):
        """Check if surface is a Window."""
        return isinstance(self.surfaceType, Window)

    @property
    def points(self):
        """Get/set points."""
        return self.__pts

    @property
    def absolutePoints(self):
        """Return absolute coordinates of points.

        If coordinate system is absolute, self.absolutePoints will be the same
        as self.points.
        """
        if self.isRelativeSystem:
            _ptgroups = range(len(self.points))
            for count, ptGroup in enumerate(self.points):
                _ptgroups[count] = [
                    (pt[0] + self.origin[0],
                     pt[1] + self.origin[1],
                     pt[2] + self.origin[2])
                    for pt in ptGroup
                ]
            return _ptgroups
        else:
            return self.points

    @points.setter
    def points(self, pts):
        """set points.

        Args:
            pts: A list of points as tuples or lists of (x, y, z).
            Points should be sorted. This class won't sort the points.
            (e.g. ((0, 0, 0), (10, 0, 0), (0, 10, 0)))
        """
        # The structure of points is list of lists so it can handle non-planar
        # surfaces which will have several subsurfaces. We don't check the structure
        # here so user can add points as needed. It will be checked once user wants
        # to write the surface to Radiance or EnergyPlus
        self.__pts = []
        self.addPointList(pts, True)
        if hasattr(self, 'isTypeSetByUser') and not self.isTypeSetByUser:
            # re-evaluate the type if it hasn't been set by user
            self.__surfaceType = self.__surfaceTypeFromPoints()

    def addPointList(self, pts, removeCurrentPoints=False):
        """Add new list of points to surface points.

        Args:
            pts: A list of points as tuples or lists of (x, y, z).
                Points should be sorted. This class won't sort the points.
                (e.g. ((0, 0, 0), (10, 0, 0), (0, 10, 0)))
            removeCurrentPoints: Set to True to remove current points.
                (Default: False)
        """
        assert isinstance(pts, (list, tuple, types.GeneratorType)), \
            "Points should be a list or a tuple or a generator"
        if len(pts) == 0:
            return
        if removeCurrentPoints:
            self.__pts = []

        if hasattr(pts[0], 'X'):
            # a single list of points from Dynamo
            self.__pts.append(tuple((pt.X, pt.Y, pt.Z) for pt in pts))

        elif hasattr(pts[0], '__iter__') and hasattr(pts[0][0], 'X'):
            # list of points list in Dynamo
            self.__pts.extend(tuple(tuple((pt.X, pt.Y, pt.Z) for pt in ptGroup)
                               for ptGroup in pts))

        elif hasattr(pts[0], '__iter__') and not hasattr(pts[0][0], '__iter__'):
            # a list of tuples as x, y, z
            self.__pts.append(pts)

        elif hasattr(pts[0], '__iter__') and hasattr(pts[0][0], '__iter__'):
            # a list of list of tuples
            self.__pts.extend(pts)

        else:
            raise ValueError('Invalid structure for input points: {}'.format(pts))

    def addPoint(self, pt, subsurfaceNumber=-1):
        """Add a single point to current surface points.

        Args:
            pt: A point as (x, y, z) e.g. (20, 20, 10)
            subsurfaceNumber: An optional input to indicate the subsurface that
            point should be added to (Default is -1)
        """
        try:
            self.__pts[subsurfaceNumber].append(pt)
        except IndexError:
            # pts is a flattened list
            self.__pts.append([pt])
        except AttributeError:
            # input is a tuple or a generator
            self.__pts[subsurfaceNumber] = list(self.__pts[subsurfaceNumber])
            self.__pts[subsurfaceNumber].append(pt)

    @property
    def radProperties(self):
        """Get and set Radiance properties."""
        return self.__radProperties

    @radProperties.setter
    def radProperties(self, radProperties):
        if radProperties is None:
            self.__radProperties = RadianceProperties()
        else:
            assert hasattr(radProperties, 'isRadianceProperties'), \
                "%s is not a valid RadianceProperties" % str(radProperties)
            self.__radProperties = radProperties

    @property
    def radianceMaterials(self):
        """Get list of Radiance materials for a honeybee surface.

        For a surface with no fenestration it will be a list with a single item,
        However for a surface with fenestration it will be a list including
        the materials of fenestration surfaces.

        You may use self.radianceMaterial (with no s at the end) to only get
        material for the surface itself.
        """
        surfaceMaterial = [self.radianceMaterial]

        if not self.isChildSurface:
            for fen in self.childrenSurfaces:
                surfaceMaterial.append(fen.radianceMaterial)

        return set(surfaceMaterial)

    @property
    def radianceMaterial(self):
        """Get and set Radiance material.

        When you set Radiance material you can pass a Boolean to determine if the
        Radiance material is set by user or is based on surface type.

        Usage:

            radianceMaterial = PlasticMaterial.bySingleReflectValue("wall_material", 0.55)
            HBSrf.radianceMaterial = (radianceMaterial, True)
            # or
            HBSrf.radianceMaterial = radianceMaterial
        """
        if self.radProperties.radianceMaterial is None:
            if self.surfaceType is not None:
                # set the material based on type
                self.radProperties.radianceMaterial = \
                    self.surfaceType.radianceMaterial

        return self.radProperties.radianceMaterial

    @radianceMaterial.setter
    def radianceMaterial(self, value):
        self.radProperties.radianceMaterial = value

    def duplicateVertices(self):
        """Duplicate surface vertices."""
        if self.isChildSurface or not self.hasChildSurfaces:
            return self.absolutePoints
        else:
            # get points for first glass face
            __glassPoints = [childSrf.absolutePoints[0]
                             for childSrf in self.childrenSurfaces]

            __facePoints = self.absolutePoints[0]

            return AnalsysiSurfacePolyline(__facePoints, __glassPoints).polyline


    def toRadString(self, includeMaterials=False, joinOutput=True):
        """Return Radiance definition for this surface as a string."""
        # prepare points for surface.
        if self.isChildSurface or not self.hasChildSurfaces:
            __pts = self.absolutePoints
        else:

            # get points for first glass face
            __glassPoints = [childSrf.absolutePoints[0]
                             for childSrf in self.childrenSurfaces]

            __facePoints = self.absolutePoints[0]

            __pts = AnalsysiSurfacePolyline(__facePoints, __glassPoints).polyline

            __pts = [__pts]

        __numPtGroups = len(__pts)
        # create a place holder for each point group (face)
        # for a planar surface __numPtGroups is only one
        __pgStrings = range(__numPtGroups)

        for ptCount, pts in enumerate(__pts):
            # modify name for each sub_surface
            _name = self.name if __numPtGroups == 1 else self.name + "_{}".format(ptCount)

            # collect definition for each subsurface
            __pgStrings[ptCount] = polygon(
                name=_name, materialName=self.radianceMaterial.name, pts=pts
            )

        if joinOutput:
            return "%s\n%s" % (self.radianceMaterial, "\n".join(__pgStrings)) \
                if includeMaterials \
                else "\n".join(__pgStrings)
        else:
            return self.radianceMaterial.toRadString(), __pgStrings \
                if includeMaterials \
                else __pgStrings

    def radStringToFile(self, filePath, includeMaterials=False):
        """Write Radiance definition for this surface to a file.

        Args:
            filePath: Full path for a valid file path (e.g. c:/ladybug/geo.rad)

        Returns:
            True in case of success. False in case of failure.
        """
        assert os.path.isdir(os.path.split(filePath)[0]), \
            "Cannot find %s." % os.path.split(filePath)[0]

        with open(filePath, "w") as outf:
            try:
                outf.write(self.toRadString(includeMaterials))
                return True
            except Exception as e:
                print "Failed to write %s to file:\n%s" % (self.name, e)
                return False

    @property
    def epProperties(self):
        """Get and set EnergyPlus properties."""
        return self.__epProperties

    @epProperties.setter
    def epProperties(self, epProperties):
        if epProperties is None:
            pass
        else:
            raise NotImplementedError

    @property
    def energyPlusMaterials(self):
        """Return list of EnergyPlus materials for this surface."""
        raise NotImplementedError
        # self.epProperties.energyPlusMaterials

    @property
    def energyPlusConstruction(self):
        """Return surface EnergyPlus construction."""
        raise NotImplementedError
        # self.epProperties.energyPlusMaterials

    def toEPString(self, includeConstruction=False, includeMaterials=False):
        """Return EnergyPlus definition for this surface."""
        raise NotImplementedError

    def ToString(self):
        """Overwrite .NET ToString method."""
        return self.__repr__()

    def __repr__(self):
        """Represnt Honeybee surface."""
        return ("HBSurface :: %s :: %s" % (self.name, self.surfaceType)) \
            .replace('Surface Type: ', '')


class AnalsysiSurfacePolyline(object):
    """Calculate AnalysisSurfacePolyline for surface with fenestrations."""

    __slots__ = ('startIndex', '_ptListA', '_ptListB')

    def __init__(self, surfacePoints, fenPoints):
        """Init class."""
        self.startIndex = 0
        self._ptListA = []
        self._ptListB = []
        self.__calculatePolyline(surfacePoints, fenPoints)

    @property
    def polyline(self):
        """Return a list of points for the single polyline.

        This list of points includes based surface and fenestrations.
        """
        return self._ptListB[:-1] + list(reversed(self._ptListA))

    @staticmethod
    def distance(pt1, pt2):
        """calculate distance between two points."""
        return math.sqrt((pt2[0] - pt1[0])**2 +
                         (pt2[1] - pt1[1])**2 +
                         (pt2[2] - pt1[2])**2)

    def __shortestDistance(self, ptList1, ptList2):
        dist = float('inf')
        xi = None
        yi = None
        for xCount, xpt in enumerate(ptList1):
            for yCount, ypt in enumerate(ptList2):
                d = self.distance(xpt, ypt)
                if d < dist:
                    dist, xi, yi = d, xCount, yCount

        return dist, xi, yi

    def __addPoints(self, source, target):
        d, si, ti = self.__shortestDistance(source, target)
        if self.startIndex < si:
            start = self.startIndex
            end = si
            self._ptListA.extend(source[start: end + 1])
            self._ptListB.extend(reversed(source[end:] + source[:start + 1]))
        else:
            start = si
            end = self.startIndex
            self._ptListA.extend(reversed(source[start: end + 1]))
            self._ptListB.extend(source[end:] + source[:start + 1])

        self.startIndex = ti

    def __calculatePolyline(self, source, targets):
        """calculate single polyline for HBSurface with Fenestration."""
        # sort point groups
        sortedTargets = sorted(targets,
                               key=lambda target: self.__shortestDistance(source, target)[0])

        self.__addPoints(source, sortedTargets[0])

        if len(sortedTargets) > 1:
            self.__calculatePolyline(sortedTargets[0], sortedTargets[1:])
        else:
            self.__addPoints(sortedTargets[0], sortedTargets[0])
</code></pre>
  </div>

  </header>

  <section id="section-items">


    <h2 class="section-title" id="header-classes">Classes</h2>
      
      <div class="item">
      <p id="honeybeex.honeybee._hbanalysissurface.AnalsysiSurfacePolyline" class="name">class <span class="ident">AnalsysiSurfacePolyline</span></p>
      
  
    <div class="desc"><p>Calculate AnalysisSurfacePolyline for surface with fenestrations.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-honeybeex.honeybee._hbanalysissurface.AnalsysiSurfacePolyline', this);">Show source &equiv;</a></p>
  <div id="source-honeybeex.honeybee._hbanalysissurface.AnalsysiSurfacePolyline" class="source">
    <pre><code>class AnalsysiSurfacePolyline(object):
    """Calculate AnalysisSurfacePolyline for surface with fenestrations."""

    __slots__ = ('startIndex', '_ptListA', '_ptListB')

    def __init__(self, surfacePoints, fenPoints):
        """Init class."""
        self.startIndex = 0
        self._ptListA = []
        self._ptListB = []
        self.__calculatePolyline(surfacePoints, fenPoints)

    @property
    def polyline(self):
        """Return a list of points for the single polyline.

        This list of points includes based surface and fenestrations.
        """
        return self._ptListB[:-1] + list(reversed(self._ptListA))

    @staticmethod
    def distance(pt1, pt2):
        """calculate distance between two points."""
        return math.sqrt((pt2[0] - pt1[0])**2 +
                         (pt2[1] - pt1[1])**2 +
                         (pt2[2] - pt1[2])**2)

    def __shortestDistance(self, ptList1, ptList2):
        dist = float('inf')
        xi = None
        yi = None
        for xCount, xpt in enumerate(ptList1):
            for yCount, ypt in enumerate(ptList2):
                d = self.distance(xpt, ypt)
                if d < dist:
                    dist, xi, yi = d, xCount, yCount

        return dist, xi, yi

    def __addPoints(self, source, target):
        d, si, ti = self.__shortestDistance(source, target)
        if self.startIndex < si:
            start = self.startIndex
            end = si
            self._ptListA.extend(source[start: end + 1])
            self._ptListB.extend(reversed(source[end:] + source[:start + 1]))
        else:
            start = si
            end = self.startIndex
            self._ptListA.extend(reversed(source[start: end + 1]))
            self._ptListB.extend(source[end:] + source[:start + 1])

        self.startIndex = ti

    def __calculatePolyline(self, source, targets):
        """calculate single polyline for HBSurface with Fenestration."""
        # sort point groups
        sortedTargets = sorted(targets,
                               key=lambda target: self.__shortestDistance(source, target)[0])

        self.__addPoints(source, sortedTargets[0])

        if len(sortedTargets) > 1:
            self.__calculatePolyline(sortedTargets[0], sortedTargets[1:])
        else:
            self.__addPoints(sortedTargets[0], sortedTargets[0])
</code></pre>
  </div>
</div>


      <div class="class">
          <h3>Ancestors (in MRO)</h3>
          <ul class="class_list">
          <li><a href="#honeybeex.honeybee._hbanalysissurface.AnalsysiSurfacePolyline">AnalsysiSurfacePolyline</a></li>
          <li>__builtin__.object</li>
          </ul>
          <h3>Static methods</h3>
            
  <div class="item">
    <div class="name def" id="honeybeex.honeybee._hbanalysissurface.AnalsysiSurfacePolyline.distance">
    <p>def <span class="ident">distance</span>(</p><p>pt1, pt2)</p>
    </div>
    

    
  
    <div class="desc"><p>calculate distance between two points.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-honeybeex.honeybee._hbanalysissurface.AnalsysiSurfacePolyline.distance', this);">Show source &equiv;</a></p>
  <div id="source-honeybeex.honeybee._hbanalysissurface.AnalsysiSurfacePolyline.distance" class="source">
    <pre><code>@staticmethod
def distance(pt1, pt2):
    """calculate distance between two points."""
    return math.sqrt((pt2[0] - pt1[0])**2 +
                     (pt2[1] - pt1[1])**2 +
                     (pt2[2] - pt1[2])**2)
</code></pre>
  </div>
</div>

  </div>
  
          <h3>Instance variables</h3>
            <div class="item">
            <p id="honeybeex.honeybee._hbanalysissurface.AnalsysiSurfacePolyline.polyline" class="name">var <span class="ident">polyline</span></p>
            

            
  
    <div class="desc"><p>Return a list of points for the single polyline.</p>
<p>This list of points includes based surface and fenestrations.</p></div>
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="honeybeex.honeybee._hbanalysissurface.AnalsysiSurfacePolyline.startIndex" class="name">var <span class="ident">startIndex</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
          <h3>Methods</h3>
            
  <div class="item">
    <div class="name def" id="honeybeex.honeybee._hbanalysissurface.AnalsysiSurfacePolyline.__init__">
    <p>def <span class="ident">__init__</span>(</p><p>self, surfacePoints, fenPoints)</p>
    </div>
    

    
  
    <div class="desc"><p>Init class.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-honeybeex.honeybee._hbanalysissurface.AnalsysiSurfacePolyline.__init__', this);">Show source &equiv;</a></p>
  <div id="source-honeybeex.honeybee._hbanalysissurface.AnalsysiSurfacePolyline.__init__" class="source">
    <pre><code>def __init__(self, surfacePoints, fenPoints):
    """Init class."""
    self.startIndex = 0
    self._ptListA = []
    self._ptListB = []
    self.__calculatePolyline(surfacePoints, fenPoints)
</code></pre>
  </div>
</div>

  </div>
  
      </div>
      </div>
      
      <div class="item">
      <p id="honeybeex.honeybee._hbanalysissurface.HBAnalysisSurface" class="name">class <span class="ident">HBAnalysisSurface</span></p>
      
  
    <div class="desc"><p>Base class for Honeybee surface.</p>
<p>Args:
    name: A unique string for surface name
    sortedPoints: A list of 3 points or more as tuple or list with three items
        (x, y, z). Points should be sorted. This class won't sort the points.
        If surfaces has multiple subsurfaces you can pass lists of point lists
        to this function (e.g. ((0, 0, 0), (10, 0, 0), (0, 10, 0))).
    surfaceType: Optional input for surface type. You can use any of the surface
        types available from surfacetype libraries or use a float number to
        indicate the type. If not indicated it will be assigned based on normal
        angle of the surface which will be calculated from surface points.
            0.0: Wall           0.5: UndergroundWall
            1.0: Roof           1.5: UndergroundCeiling
            2.0: Floor          2.25: UndergroundSlab
            2.5: SlabOnGrade    2.75: ExposedFloor
            3.0: Ceiling        4.0: AirWall
            5.0: Window         6.0: Context
    isNameSetByUser: If you want the name to be changed by honeybee any case
        set isNameSetByUser to True. Default is set to False which let Honeybee
        to rename the surface in cases like creating a newHBZone.
    radProperties: Radiance properties for this surface. If empty default
        RADProperties will be assigned to surface by Honeybee.
    epProperties: EnergyPlus properties for this surface. If empty default
        epProperties will be assigned to surface by Honeybee.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-honeybeex.honeybee._hbanalysissurface.HBAnalysisSurface', this);">Show source &equiv;</a></p>
  <div id="source-honeybeex.honeybee._hbanalysissurface.HBAnalysisSurface" class="source">
    <pre><code>class HBAnalysisSurface(HBObject):
    """Base class for Honeybee surface.

    Args:
        name: A unique string for surface name
        sortedPoints: A list of 3 points or more as tuple or list with three items
            (x, y, z). Points should be sorted. This class won't sort the points.
            If surfaces has multiple subsurfaces you can pass lists of point lists
            to this function (e.g. ((0, 0, 0), (10, 0, 0), (0, 10, 0))).
        surfaceType: Optional input for surface type. You can use any of the surface
            types available from surfacetype libraries or use a float number to
            indicate the type. If not indicated it will be assigned based on normal
            angle of the surface which will be calculated from surface points.
                0.0: Wall           0.5: UndergroundWall
                1.0: Roof           1.5: UndergroundCeiling
                2.0: Floor          2.25: UndergroundSlab
                2.5: SlabOnGrade    2.75: ExposedFloor
                3.0: Ceiling        4.0: AirWall
                5.0: Window         6.0: Context
        isNameSetByUser: If you want the name to be changed by honeybee any case
            set isNameSetByUser to True. Default is set to False which let Honeybee
            to rename the surface in cases like creating a newHBZone.
        radProperties: Radiance properties for this surface. If empty default
            RADProperties will be assigned to surface by Honeybee.
        epProperties: EnergyPlus properties for this surface. If empty default
            epProperties will be assigned to surface by Honeybee.
    """

    __metaclass__ = ABCMeta

    def __init__(self, name, sortedPoints=[], surfaceType=None,
                 isNameSetByUser=False, isTypeSetByUser=False,
                 radProperties=None, epProperties=None):
        """Initialize Honeybee Surface."""
        self.name = (name, isNameSetByUser)
        """Surface name."""
        self.points = sortedPoints
        """A list of points as tuples or lists of (x, y, z).
        Points should be sorted. This class won't sort the points.
        (e.g. ((0, 0, 0), (10, 0, 0), (0, 10, 0)))
        """
        self.surfaceType = (surfaceType, isTypeSetByUser)
        """Surface type."""
        self.epProperties = epProperties
        """EnergyPlus properties for this surface. If empty default
            EPProperties will be assigned to surface by Honeybee."""
        self.radProperties = radProperties
        """Radiance properties for this surface. If empty default
            RADProperties will be assigned to surface by Honeybee.
        """

    @property
    def isHBAnalysisSurface(self):
        """Return True for HBSurface."""
        return True

    @abstractproperty
    def isChildSurface(self):
        """Return True if Honeybee surface is Fenestration Surface."""
        pass

    @abstractproperty
    def parent(self):
        """Return parent for HBAnalysisSurface.

        Parent will be a HBZone for a HBSurface, and a HBSurface for a
        HBFenSurface.
        """
        pass

    @property
    def isRelativeSystem(self):
        """Return True if coordinate system is relative."""
        if self.parent is None:
            return False
        else:
            return self.parent.isRelativeSystem

    @property
    def origin(self):
        """Get origin of the coordinate system for this surface.

        For Absolute system the value is always (0, 0, 0).
        """
        return self.parent.origin

    @property
    def name(self):
        """Retuen surface name."""
        return self.__name

    # TODO: name should be checked not to have illegal charecters for ep and radiance
    @name.setter
    def name(self, values):
        """Set name and isSetByUser property.

        Args:
            values: A name or a tuple as (name, isSetByUser)

        Usage:
            HBSrf.name = "surface_001"
            # or
            HBSrf.name = ("mySurfaceName", True)
        """
        try:
            # check if user passed a tuple
            if type(values) is str:
                raise TypeError
            __newName, __isNameSetByUser = values
        except ValueError:
            # user is passing a list or tuple with one ValueError
            __newName = values[0]
            __isNameSetByUser = False  # if not indicated assume it is not set by user.
        except TypeError:
            # user just passed a single value which is the name
            __newName = values
            __isNameSetByUser = False  # if not indicated assume it is not set by user.
        finally:
            # set new name
            self.__name = str(__newName)
            self.__isNameSetByUser = __isNameSetByUser

    def isNameSetByUser(self):
        """Return if name is set by user.

        If name is set by user the surface will never be renamed automatically.
        """
        return self.__isNameSetByUser

    @property
    def surfaceTypes(self):
        """Return Honeybee valid surface types."""
        _surfaceTypes = {0.0: 'Wall', 0.5: 'UndergroundWall', 1.0: 'Roof',
                         1.5: 'UndergroundCeiling', 2.0: 'Floor',
                         2.25: 'UndergroundSlab', 2.5: 'SlabOnGrade',
                         2.75: 'ExposedFloor', 3.0: 'Ceiling', 4.0: 'AirWall',
                         6.0: 'Context'}

        return _surfaceTypes

    @property
    def surfaceType(self):
        """Get and set Surface Type."""
        return self.__surfaceType

    @surfaceType.setter
    def surfaceType(self, values):
        # let's assume values in surfaceType and Boolean
        __surfaceType, __isTypeSetByUser = values

        # Now let's check the input for surface type
        if __surfaceType is not None:
            # it is either a number or already a valid type
            if isinstance(__surfaceType, surfacetype.surfaceTypeBase):
                self.__surfaceType = __surfaceType
            else:
                try:
                    # it should be a key value
                    self.__surfaceType = \
                        surfacetype.SurfaceTypes.getTypeByKey(__surfaceType)()
                except:
                    raise ValueError('%s is not a valid surface type.' % __surfaceType)
        else:
            # try to figure it out based on points
            if self.points == []:
                # unless user add the points we can't find the type
                self.__surfaceType = None
            else:
                self.__surfaceType = self.__surfaceTypeFromPoints()
                __isTypeSetByUser = False

        self.__isTypeSetByUser = __isTypeSetByUser

    def __surfaceTypeFromPoints(self):
        normal = go.calculateNormalFromPoints(self.points[0])
        __angleToZAxis = go.calculateVectorAngleToZAxis(normal)
        return surfacetype.SurfaceTypes.byNormalAngleAndPoints(__angleToZAxis, self.points[0])()

    @property
    def isTypeSetByUser(self):
        """Check if the type for surface is set by user."""
        return self.__isTypeSetByUser

    @property
    def isFloor(self):
        """Check if surface is a Floor."""
        return isinstance(self.surfaceType, Floor)

    @property
    def isWall(self):
        """Check if surface is a Wall."""
        return isinstance(self.surfaceType, Wall)

    @property
    def isCeiling(self):
        """Check if surface is a Ceiling."""
        return isinstance(self.surfaceType, Ceiling)

    @property
    def isWindow(self):
        """Check if surface is a Window."""
        return isinstance(self.surfaceType, Window)

    @property
    def points(self):
        """Get/set points."""
        return self.__pts

    @property
    def absolutePoints(self):
        """Return absolute coordinates of points.

        If coordinate system is absolute, self.absolutePoints will be the same
        as self.points.
        """
        if self.isRelativeSystem:
            _ptgroups = range(len(self.points))
            for count, ptGroup in enumerate(self.points):
                _ptgroups[count] = [
                    (pt[0] + self.origin[0],
                     pt[1] + self.origin[1],
                     pt[2] + self.origin[2])
                    for pt in ptGroup
                ]
            return _ptgroups
        else:
            return self.points

    @points.setter
    def points(self, pts):
        """set points.

        Args:
            pts: A list of points as tuples or lists of (x, y, z).
            Points should be sorted. This class won't sort the points.
            (e.g. ((0, 0, 0), (10, 0, 0), (0, 10, 0)))
        """
        # The structure of points is list of lists so it can handle non-planar
        # surfaces which will have several subsurfaces. We don't check the structure
        # here so user can add points as needed. It will be checked once user wants
        # to write the surface to Radiance or EnergyPlus
        self.__pts = []
        self.addPointList(pts, True)
        if hasattr(self, 'isTypeSetByUser') and not self.isTypeSetByUser:
            # re-evaluate the type if it hasn't been set by user
            self.__surfaceType = self.__surfaceTypeFromPoints()

    def addPointList(self, pts, removeCurrentPoints=False):
        """Add new list of points to surface points.

        Args:
            pts: A list of points as tuples or lists of (x, y, z).
                Points should be sorted. This class won't sort the points.
                (e.g. ((0, 0, 0), (10, 0, 0), (0, 10, 0)))
            removeCurrentPoints: Set to True to remove current points.
                (Default: False)
        """
        assert isinstance(pts, (list, tuple, types.GeneratorType)), \
            "Points should be a list or a tuple or a generator"
        if len(pts) == 0:
            return
        if removeCurrentPoints:
            self.__pts = []

        if hasattr(pts[0], 'X'):
            # a single list of points from Dynamo
            self.__pts.append(tuple((pt.X, pt.Y, pt.Z) for pt in pts))

        elif hasattr(pts[0], '__iter__') and hasattr(pts[0][0], 'X'):
            # list of points list in Dynamo
            self.__pts.extend(tuple(tuple((pt.X, pt.Y, pt.Z) for pt in ptGroup)
                               for ptGroup in pts))

        elif hasattr(pts[0], '__iter__') and not hasattr(pts[0][0], '__iter__'):
            # a list of tuples as x, y, z
            self.__pts.append(pts)

        elif hasattr(pts[0], '__iter__') and hasattr(pts[0][0], '__iter__'):
            # a list of list of tuples
            self.__pts.extend(pts)

        else:
            raise ValueError('Invalid structure for input points: {}'.format(pts))

    def addPoint(self, pt, subsurfaceNumber=-1):
        """Add a single point to current surface points.

        Args:
            pt: A point as (x, y, z) e.g. (20, 20, 10)
            subsurfaceNumber: An optional input to indicate the subsurface that
            point should be added to (Default is -1)
        """
        try:
            self.__pts[subsurfaceNumber].append(pt)
        except IndexError:
            # pts is a flattened list
            self.__pts.append([pt])
        except AttributeError:
            # input is a tuple or a generator
            self.__pts[subsurfaceNumber] = list(self.__pts[subsurfaceNumber])
            self.__pts[subsurfaceNumber].append(pt)

    @property
    def radProperties(self):
        """Get and set Radiance properties."""
        return self.__radProperties

    @radProperties.setter
    def radProperties(self, radProperties):
        if radProperties is None:
            self.__radProperties = RadianceProperties()
        else:
            assert hasattr(radProperties, 'isRadianceProperties'), \
                "%s is not a valid RadianceProperties" % str(radProperties)
            self.__radProperties = radProperties

    @property
    def radianceMaterials(self):
        """Get list of Radiance materials for a honeybee surface.

        For a surface with no fenestration it will be a list with a single item,
        However for a surface with fenestration it will be a list including
        the materials of fenestration surfaces.

        You may use self.radianceMaterial (with no s at the end) to only get
        material for the surface itself.
        """
        surfaceMaterial = [self.radianceMaterial]

        if not self.isChildSurface:
            for fen in self.childrenSurfaces:
                surfaceMaterial.append(fen.radianceMaterial)

        return set(surfaceMaterial)

    @property
    def radianceMaterial(self):
        """Get and set Radiance material.

        When you set Radiance material you can pass a Boolean to determine if the
        Radiance material is set by user or is based on surface type.

        Usage:

            radianceMaterial = PlasticMaterial.bySingleReflectValue("wall_material", 0.55)
            HBSrf.radianceMaterial = (radianceMaterial, True)
            # or
            HBSrf.radianceMaterial = radianceMaterial
        """
        if self.radProperties.radianceMaterial is None:
            if self.surfaceType is not None:
                # set the material based on type
                self.radProperties.radianceMaterial = \
                    self.surfaceType.radianceMaterial

        return self.radProperties.radianceMaterial

    @radianceMaterial.setter
    def radianceMaterial(self, value):
        self.radProperties.radianceMaterial = value

    def duplicateVertices(self):
        """Duplicate surface vertices."""
        if self.isChildSurface or not self.hasChildSurfaces:
            return self.absolutePoints
        else:
            # get points for first glass face
            __glassPoints = [childSrf.absolutePoints[0]
                             for childSrf in self.childrenSurfaces]

            __facePoints = self.absolutePoints[0]

            return AnalsysiSurfacePolyline(__facePoints, __glassPoints).polyline


    def toRadString(self, includeMaterials=False, joinOutput=True):
        """Return Radiance definition for this surface as a string."""
        # prepare points for surface.
        if self.isChildSurface or not self.hasChildSurfaces:
            __pts = self.absolutePoints
        else:

            # get points for first glass face
            __glassPoints = [childSrf.absolutePoints[0]
                             for childSrf in self.childrenSurfaces]

            __facePoints = self.absolutePoints[0]

            __pts = AnalsysiSurfacePolyline(__facePoints, __glassPoints).polyline

            __pts = [__pts]

        __numPtGroups = len(__pts)
        # create a place holder for each point group (face)
        # for a planar surface __numPtGroups is only one
        __pgStrings = range(__numPtGroups)

        for ptCount, pts in enumerate(__pts):
            # modify name for each sub_surface
            _name = self.name if __numPtGroups == 1 else self.name + "_{}".format(ptCount)

            # collect definition for each subsurface
            __pgStrings[ptCount] = polygon(
                name=_name, materialName=self.radianceMaterial.name, pts=pts
            )

        if joinOutput:
            return "%s\n%s" % (self.radianceMaterial, "\n".join(__pgStrings)) \
                if includeMaterials \
                else "\n".join(__pgStrings)
        else:
            return self.radianceMaterial.toRadString(), __pgStrings \
                if includeMaterials \
                else __pgStrings

    def radStringToFile(self, filePath, includeMaterials=False):
        """Write Radiance definition for this surface to a file.

        Args:
            filePath: Full path for a valid file path (e.g. c:/ladybug/geo.rad)

        Returns:
            True in case of success. False in case of failure.
        """
        assert os.path.isdir(os.path.split(filePath)[0]), \
            "Cannot find %s." % os.path.split(filePath)[0]

        with open(filePath, "w") as outf:
            try:
                outf.write(self.toRadString(includeMaterials))
                return True
            except Exception as e:
                print "Failed to write %s to file:\n%s" % (self.name, e)
                return False

    @property
    def epProperties(self):
        """Get and set EnergyPlus properties."""
        return self.__epProperties

    @epProperties.setter
    def epProperties(self, epProperties):
        if epProperties is None:
            pass
        else:
            raise NotImplementedError

    @property
    def energyPlusMaterials(self):
        """Return list of EnergyPlus materials for this surface."""
        raise NotImplementedError
        # self.epProperties.energyPlusMaterials

    @property
    def energyPlusConstruction(self):
        """Return surface EnergyPlus construction."""
        raise NotImplementedError
        # self.epProperties.energyPlusMaterials

    def toEPString(self, includeConstruction=False, includeMaterials=False):
        """Return EnergyPlus definition for this surface."""
        raise NotImplementedError

    def ToString(self):
        """Overwrite .NET ToString method."""
        return self.__repr__()

    def __repr__(self):
        """Represnt Honeybee surface."""
        return ("HBSurface :: %s :: %s" % (self.name, self.surfaceType)) \
            .replace('Surface Type: ', '')
</code></pre>
  </div>
</div>


      <div class="class">
          <h3>Ancestors (in MRO)</h3>
          <ul class="class_list">
          <li><a href="#honeybeex.honeybee._hbanalysissurface.HBAnalysisSurface">HBAnalysisSurface</a></li>
          <li>honeybeex.honeybee.hbobject.HBObject</li>
          <li>__builtin__.object</li>
          </ul>
          <h3>Instance variables</h3>
            <div class="item">
            <p id="honeybeex.honeybee._hbanalysissurface.HBAnalysisSurface.absolutePoints" class="name">var <span class="ident">absolutePoints</span></p>
            

            
  
    <div class="desc"><p>Return absolute coordinates of points.</p>
<p>If coordinate system is absolute, self.absolutePoints will be the same
as self.points.</p></div>
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="honeybeex.honeybee._hbanalysissurface.HBAnalysisSurface.energyPlusConstruction" class="name">var <span class="ident">energyPlusConstruction</span></p>
            

            
  
    <div class="desc"><p>Return surface EnergyPlus construction.</p></div>
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="honeybeex.honeybee._hbanalysissurface.HBAnalysisSurface.energyPlusMaterials" class="name">var <span class="ident">energyPlusMaterials</span></p>
            

            
  
    <div class="desc"><p>Return list of EnergyPlus materials for this surface.</p></div>
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="honeybeex.honeybee._hbanalysissurface.HBAnalysisSurface.epProperties" class="name">var <span class="ident">epProperties</span></p>
            

            
  
    <div class="desc"><p>EnergyPlus properties for this surface. If empty default
EPProperties will be assigned to surface by Honeybee.</p></div>
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="honeybeex.honeybee._hbanalysissurface.HBAnalysisSurface.isCeiling" class="name">var <span class="ident">isCeiling</span></p>
            

            
  
    <div class="desc"><p>Check if surface is a Ceiling.</p></div>
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="honeybeex.honeybee._hbanalysissurface.HBAnalysisSurface.isChildSurface" class="name">var <span class="ident">isChildSurface</span></p>
            

            
  
    <div class="desc"><p>Return True if Honeybee surface is Fenestration Surface.</p></div>
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="honeybeex.honeybee._hbanalysissurface.HBAnalysisSurface.isFloor" class="name">var <span class="ident">isFloor</span></p>
            

            
  
    <div class="desc"><p>Check if surface is a Floor.</p></div>
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="honeybeex.honeybee._hbanalysissurface.HBAnalysisSurface.isHBAnalysisSurface" class="name">var <span class="ident">isHBAnalysisSurface</span></p>
            

            
  
    <div class="desc"><p>Return True for HBSurface.</p></div>
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="honeybeex.honeybee._hbanalysissurface.HBAnalysisSurface.isHBObject" class="name">var <span class="ident">isHBObject</span></p>
            

            
  
    <div class="desc"><p>Return True.</p></div>
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="honeybeex.honeybee._hbanalysissurface.HBAnalysisSurface.isRelativeSystem" class="name">var <span class="ident">isRelativeSystem</span></p>
            

            
  
    <div class="desc"><p>Return True if coordinate system is relative.</p></div>
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="honeybeex.honeybee._hbanalysissurface.HBAnalysisSurface.isTypeSetByUser" class="name">var <span class="ident">isTypeSetByUser</span></p>
            

            
  
    <div class="desc"><p>Check if the type for surface is set by user.</p></div>
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="honeybeex.honeybee._hbanalysissurface.HBAnalysisSurface.isWall" class="name">var <span class="ident">isWall</span></p>
            

            
  
    <div class="desc"><p>Check if surface is a Wall.</p></div>
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="honeybeex.honeybee._hbanalysissurface.HBAnalysisSurface.isWindow" class="name">var <span class="ident">isWindow</span></p>
            

            
  
    <div class="desc"><p>Check if surface is a Window.</p></div>
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="honeybeex.honeybee._hbanalysissurface.HBAnalysisSurface.name" class="name">var <span class="ident">name</span></p>
            

            
  
    <div class="desc"><p>Surface name.</p></div>
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="honeybeex.honeybee._hbanalysissurface.HBAnalysisSurface.origin" class="name">var <span class="ident">origin</span></p>
            

            
  
    <div class="desc"><p>Get origin of the coordinate system for this surface.</p>
<p>For Absolute system the value is always (0, 0, 0).</p></div>
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="honeybeex.honeybee._hbanalysissurface.HBAnalysisSurface.parent" class="name">var <span class="ident">parent</span></p>
            

            
  
    <div class="desc"><p>Return parent for HBAnalysisSurface.</p>
<p>Parent will be a HBZone for a HBSurface, and a HBSurface for a
HBFenSurface.</p></div>
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="honeybeex.honeybee._hbanalysissurface.HBAnalysisSurface.points" class="name">var <span class="ident">points</span></p>
            

            
  
    <div class="desc"><p>A list of points as tuples or lists of (x, y, z).
Points should be sorted. This class won't sort the points.
(e.g. ((0, 0, 0), (10, 0, 0), (0, 10, 0)))</p></div>
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="honeybeex.honeybee._hbanalysissurface.HBAnalysisSurface.radProperties" class="name">var <span class="ident">radProperties</span></p>
            

            
  
    <div class="desc"><p>Radiance properties for this surface. If empty default
RADProperties will be assigned to surface by Honeybee.</p></div>
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="honeybeex.honeybee._hbanalysissurface.HBAnalysisSurface.radianceMaterial" class="name">var <span class="ident">radianceMaterial</span></p>
            

            
  
    <div class="desc"><p>Get and set Radiance material.</p>
<p>When you set Radiance material you can pass a Boolean to determine if the
Radiance material is set by user or is based on surface type.</p>
<p>Usage:</p>
<pre><code>radianceMaterial = PlasticMaterial.bySingleReflectValue("wall_material", 0.55)
HBSrf.radianceMaterial = (radianceMaterial, True)
# or
HBSrf.radianceMaterial = radianceMaterial
</code></pre></div>
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="honeybeex.honeybee._hbanalysissurface.HBAnalysisSurface.radianceMaterials" class="name">var <span class="ident">radianceMaterials</span></p>
            

            
  
    <div class="desc"><p>Get list of Radiance materials for a honeybee surface.</p>
<p>For a surface with no fenestration it will be a list with a single item,
However for a surface with fenestration it will be a list including
the materials of fenestration surfaces.</p>
<p>You may use self.radianceMaterial (with no s at the end) to only get
material for the surface itself.</p></div>
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="honeybeex.honeybee._hbanalysissurface.HBAnalysisSurface.surfaceType" class="name">var <span class="ident">surfaceType</span></p>
            

            
  
    <div class="desc"><p>Surface type.</p></div>
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="honeybeex.honeybee._hbanalysissurface.HBAnalysisSurface.surfaceTypes" class="name">var <span class="ident">surfaceTypes</span></p>
            

            
  
    <div class="desc"><p>Return Honeybee valid surface types.</p></div>
  <div class="source_cont">
</div>

            </div>
          <h3>Methods</h3>
            
  <div class="item">
    <div class="name def" id="honeybeex.honeybee._hbanalysissurface.HBAnalysisSurface.__init__">
    <p>def <span class="ident">__init__</span>(</p><p>self, name, sortedPoints=[], surfaceType=None, isNameSetByUser=False, isTypeSetByUser=False, radProperties=None, epProperties=None)</p>
    </div>
    

    
  
    <div class="desc"><p>Initialize Honeybee Surface.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-honeybeex.honeybee._hbanalysissurface.HBAnalysisSurface.__init__', this);">Show source &equiv;</a></p>
  <div id="source-honeybeex.honeybee._hbanalysissurface.HBAnalysisSurface.__init__" class="source">
    <pre><code>def __init__(self, name, sortedPoints=[], surfaceType=None,
             isNameSetByUser=False, isTypeSetByUser=False,
             radProperties=None, epProperties=None):
    """Initialize Honeybee Surface."""
    self.name = (name, isNameSetByUser)
    """Surface name."""
    self.points = sortedPoints
    """A list of points as tuples or lists of (x, y, z).
    Points should be sorted. This class won't sort the points.
    (e.g. ((0, 0, 0), (10, 0, 0), (0, 10, 0)))
    """
    self.surfaceType = (surfaceType, isTypeSetByUser)
    """Surface type."""
    self.epProperties = epProperties
    """EnergyPlus properties for this surface. If empty default
        EPProperties will be assigned to surface by Honeybee."""
    self.radProperties = radProperties
    """Radiance properties for this surface. If empty default
        RADProperties will be assigned to surface by Honeybee.
    """
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="honeybeex.honeybee._hbanalysissurface.HBAnalysisSurface.ToString">
    <p>def <span class="ident">ToString</span>(</p><p>self)</p>
    </div>
    

    
  
    <div class="desc"><p>Overwrite .NET ToString method.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-honeybeex.honeybee._hbanalysissurface.HBAnalysisSurface.ToString', this);">Show source &equiv;</a></p>
  <div id="source-honeybeex.honeybee._hbanalysissurface.HBAnalysisSurface.ToString" class="source">
    <pre><code>def ToString(self):
    """Overwrite .NET ToString method."""
    return self.__repr__()
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="honeybeex.honeybee._hbanalysissurface.HBAnalysisSurface.addPoint">
    <p>def <span class="ident">addPoint</span>(</p><p>self, pt, subsurfaceNumber=-1)</p>
    </div>
    

    
  
    <div class="desc"><p>Add a single point to current surface points.</p>
<p>Args:
    pt: A point as (x, y, z) e.g. (20, 20, 10)
    subsurfaceNumber: An optional input to indicate the subsurface that
    point should be added to (Default is -1)</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-honeybeex.honeybee._hbanalysissurface.HBAnalysisSurface.addPoint', this);">Show source &equiv;</a></p>
  <div id="source-honeybeex.honeybee._hbanalysissurface.HBAnalysisSurface.addPoint" class="source">
    <pre><code>def addPoint(self, pt, subsurfaceNumber=-1):
    """Add a single point to current surface points.
    Args:
        pt: A point as (x, y, z) e.g. (20, 20, 10)
        subsurfaceNumber: An optional input to indicate the subsurface that
        point should be added to (Default is -1)
    """
    try:
        self.__pts[subsurfaceNumber].append(pt)
    except IndexError:
        # pts is a flattened list
        self.__pts.append([pt])
    except AttributeError:
        # input is a tuple or a generator
        self.__pts[subsurfaceNumber] = list(self.__pts[subsurfaceNumber])
        self.__pts[subsurfaceNumber].append(pt)
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="honeybeex.honeybee._hbanalysissurface.HBAnalysisSurface.addPointList">
    <p>def <span class="ident">addPointList</span>(</p><p>self, pts, removeCurrentPoints=False)</p>
    </div>
    

    
  
    <div class="desc"><p>Add new list of points to surface points.</p>
<p>Args:
    pts: A list of points as tuples or lists of (x, y, z).
        Points should be sorted. This class won't sort the points.
        (e.g. ((0, 0, 0), (10, 0, 0), (0, 10, 0)))
    removeCurrentPoints: Set to True to remove current points.
        (Default: False)</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-honeybeex.honeybee._hbanalysissurface.HBAnalysisSurface.addPointList', this);">Show source &equiv;</a></p>
  <div id="source-honeybeex.honeybee._hbanalysissurface.HBAnalysisSurface.addPointList" class="source">
    <pre><code>def addPointList(self, pts, removeCurrentPoints=False):
    """Add new list of points to surface points.
    Args:
        pts: A list of points as tuples or lists of (x, y, z).
            Points should be sorted. This class won't sort the points.
            (e.g. ((0, 0, 0), (10, 0, 0), (0, 10, 0)))
        removeCurrentPoints: Set to True to remove current points.
            (Default: False)
    """
    assert isinstance(pts, (list, tuple, types.GeneratorType)), \
        "Points should be a list or a tuple or a generator"
    if len(pts) == 0:
        return
    if removeCurrentPoints:
        self.__pts = []
    if hasattr(pts[0], 'X'):
        # a single list of points from Dynamo
        self.__pts.append(tuple((pt.X, pt.Y, pt.Z) for pt in pts))
    elif hasattr(pts[0], '__iter__') and hasattr(pts[0][0], 'X'):
        # list of points list in Dynamo
        self.__pts.extend(tuple(tuple((pt.X, pt.Y, pt.Z) for pt in ptGroup)
                           for ptGroup in pts))
    elif hasattr(pts[0], '__iter__') and not hasattr(pts[0][0], '__iter__'):
        # a list of tuples as x, y, z
        self.__pts.append(pts)
    elif hasattr(pts[0], '__iter__') and hasattr(pts[0][0], '__iter__'):
        # a list of list of tuples
        self.__pts.extend(pts)
    else:
        raise ValueError('Invalid structure for input points: {}'.format(pts))
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="honeybeex.honeybee._hbanalysissurface.HBAnalysisSurface.duplicateVertices">
    <p>def <span class="ident">duplicateVertices</span>(</p><p>self)</p>
    </div>
    

    
  
    <div class="desc"><p>Duplicate surface vertices.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-honeybeex.honeybee._hbanalysissurface.HBAnalysisSurface.duplicateVertices', this);">Show source &equiv;</a></p>
  <div id="source-honeybeex.honeybee._hbanalysissurface.HBAnalysisSurface.duplicateVertices" class="source">
    <pre><code>def duplicateVertices(self):
    """Duplicate surface vertices."""
    if self.isChildSurface or not self.hasChildSurfaces:
        return self.absolutePoints
    else:
        # get points for first glass face
        __glassPoints = [childSrf.absolutePoints[0]
                         for childSrf in self.childrenSurfaces]
        __facePoints = self.absolutePoints[0]
        return AnalsysiSurfacePolyline(__facePoints, __glassPoints).polyline
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="honeybeex.honeybee._hbanalysissurface.HBAnalysisSurface.isNameSetByUser">
    <p>def <span class="ident">isNameSetByUser</span>(</p><p>self)</p>
    </div>
    

    
  
    <div class="desc"><p>Return if name is set by user.</p>
<p>If name is set by user the surface will never be renamed automatically.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-honeybeex.honeybee._hbanalysissurface.HBAnalysisSurface.isNameSetByUser', this);">Show source &equiv;</a></p>
  <div id="source-honeybeex.honeybee._hbanalysissurface.HBAnalysisSurface.isNameSetByUser" class="source">
    <pre><code>def isNameSetByUser(self):
    """Return if name is set by user.
    If name is set by user the surface will never be renamed automatically.
    """
    return self.__isNameSetByUser
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="honeybeex.honeybee._hbanalysissurface.HBAnalysisSurface.radStringToFile">
    <p>def <span class="ident">radStringToFile</span>(</p><p>self, filePath, includeMaterials=False)</p>
    </div>
    

    
  
    <div class="desc"><p>Write Radiance definition for this surface to a file.</p>
<p>Args:
    filePath: Full path for a valid file path (e.g. c:/ladybug/geo.rad)</p>
<p>Returns:
    True in case of success. False in case of failure.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-honeybeex.honeybee._hbanalysissurface.HBAnalysisSurface.radStringToFile', this);">Show source &equiv;</a></p>
  <div id="source-honeybeex.honeybee._hbanalysissurface.HBAnalysisSurface.radStringToFile" class="source">
    <pre><code>def radStringToFile(self, filePath, includeMaterials=False):
    """Write Radiance definition for this surface to a file.
    Args:
        filePath: Full path for a valid file path (e.g. c:/ladybug/geo.rad)
    Returns:
        True in case of success. False in case of failure.
    """
    assert os.path.isdir(os.path.split(filePath)[0]), \
        "Cannot find %s." % os.path.split(filePath)[0]
    with open(filePath, "w") as outf:
        try:
            outf.write(self.toRadString(includeMaterials))
            return True
        except Exception as e:
            print "Failed to write %s to file:\n%s" % (self.name, e)
            return False
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="honeybeex.honeybee._hbanalysissurface.HBAnalysisSurface.toEPString">
    <p>def <span class="ident">toEPString</span>(</p><p>self, includeConstruction=False, includeMaterials=False)</p>
    </div>
    

    
  
    <div class="desc"><p>Return EnergyPlus definition for this surface.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-honeybeex.honeybee._hbanalysissurface.HBAnalysisSurface.toEPString', this);">Show source &equiv;</a></p>
  <div id="source-honeybeex.honeybee._hbanalysissurface.HBAnalysisSurface.toEPString" class="source">
    <pre><code>def toEPString(self, includeConstruction=False, includeMaterials=False):
    """Return EnergyPlus definition for this surface."""
    raise NotImplementedError
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="honeybeex.honeybee._hbanalysissurface.HBAnalysisSurface.toRadString">
    <p>def <span class="ident">toRadString</span>(</p><p>self, includeMaterials=False, joinOutput=True)</p>
    </div>
    

    
  
    <div class="desc"><p>Return Radiance definition for this surface as a string.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-honeybeex.honeybee._hbanalysissurface.HBAnalysisSurface.toRadString', this);">Show source &equiv;</a></p>
  <div id="source-honeybeex.honeybee._hbanalysissurface.HBAnalysisSurface.toRadString" class="source">
    <pre><code>def toRadString(self, includeMaterials=False, joinOutput=True):
    """Return Radiance definition for this surface as a string."""
    # prepare points for surface.
    if self.isChildSurface or not self.hasChildSurfaces:
        __pts = self.absolutePoints
    else:
        # get points for first glass face
        __glassPoints = [childSrf.absolutePoints[0]
                         for childSrf in self.childrenSurfaces]
        __facePoints = self.absolutePoints[0]
        __pts = AnalsysiSurfacePolyline(__facePoints, __glassPoints).polyline
        __pts = [__pts]
    __numPtGroups = len(__pts)
    # create a place holder for each point group (face)
    # for a planar surface __numPtGroups is only one
    __pgStrings = range(__numPtGroups)
    for ptCount, pts in enumerate(__pts):
        # modify name for each sub_surface
        _name = self.name if __numPtGroups == 1 else self.name + "_{}".format(ptCount)
        # collect definition for each subsurface
        __pgStrings[ptCount] = polygon(
            name=_name, materialName=self.radianceMaterial.name, pts=pts
        )
    if joinOutput:
        return "%s\n%s" % (self.radianceMaterial, "\n".join(__pgStrings)) \
            if includeMaterials \
            else "\n".join(__pgStrings)
    else:
        return self.radianceMaterial.toRadString(), __pgStrings \
            if includeMaterials \
            else __pgStrings
</code></pre>
  </div>
</div>

  </div>
  
      </div>
      </div>

  </section>

    </article>
  <div class="clear"> </div>
  <footer id="footer">
    <p>
      Documentation generated by
      <a href="https://github.com/BurntSushi/pdoc">pdoc 0.3.1</a>
    </p>

    <p>pdoc is in the public domain with the
      <a href="http://unlicense.org">UNLICENSE</a>
    </p>
  </footer>
</div>
<script>hljs.initHighlightingOnLoad();</script>
</body>
</html>
